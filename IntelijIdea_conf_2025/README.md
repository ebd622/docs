# IntelliJ IDEA Conf 2025

[IntelliJ IDEA Conf 2025](https://www.youtube.com/playlist?list=PLPZy-hmwOdEV1aAV4qqXkqde7OpjsVLfb)

* Sessions: https://nljug.org/foojay/youre-invited-to-intellij-idea-conf-2025/
* Day1: https://www.youtube.com/live/Bd8EA8XKyLQ?si=Md9FMqXxEFL_Hfsf
* Day2: https://www.youtube.com/live/qg6tj8Tf36E?si=G5i1hcqRdvs8-6pW

#### Day2: Sudo, Make Me a Sandwich!"
[10:17](https://www.youtube.com/live/qg6tj8Tf36E?t=617s) – "Sudo, Make Me a Sandwich!" – Live Coding With Agentic AI in IntelliJ IDEA by Anton Arhipov
* Levels of AI assistance (from Min to Max)
  * **Minimal AI-assisted completion**: I know what I am doing let me do it myself
  * **More verbose completions are acceptable**: I know what I want, I don't know how exactly
  * **In-editor code generation with minimalistic prompts**: I know what I want, I want to move faster, generate code for me
  * **Chat-assisted programming**: I know what, I vaguely know how, provide me the guidelines
  * **Agent-assisted programming "Directive coding"**: I know what I want, I need help building it. I will quickly check the code and direct the agent with clarifying instructions
  * Agent-assisted application generation a.k.a. "Vibe coding": I have no idea how to but I want to build it - "sudo, make me a sandwich"
* Vibe Coding [15:08]

#### Day2: OOP vs. DOP: Which One to Choose?
[7:09:48](https://www.youtube.com/live/qg6tj8Tf36E?t=25788s) – OOP vs. DOP: Which One to Choose? by Venkat Subramaniam </br>
DOP - Data oriented programing
* Four pillars of OOP (7:11:00)
  * Abstration (a way to deal with complexity)
  * Incapsulation (a way to separate what we do from how we do it)
  * Inheritance (a weakest pillar of OOP? Languages like Python, Javascript, Ruby don't rely on Inheritance)
  * Polymorphism (seems to be the fost important pillar)
* Polymorphism is essence of OOP (7:11:00)
* Factory and visitor patterns? (7:26:00)
  * We often find that when a language is more power, **we tend to use less patterns**
  * Why? Because **patterns become natural features of languages**
  * Some time patterns can bring *accidental complexity* and may violate [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself#:~:text=%22Don't%20repeat%20yourself%22,redundancy%20in%20the%20first%20place.) principal (like in the discussed example)
  * Overal this becoms very highly complex and clamsu code
  * Design and atchitecture is full of trade offs
 * Violation [open-closed](https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle) proncipal (7:41:40)

* Examples: https://github.com/ebd622/java-samples/tree/main/dop-app



